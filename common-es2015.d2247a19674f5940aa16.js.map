{"version":3,"sources":["webpack:///node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js","webpack:///src/app/models/enums/tab-id.ts","webpack:///node_modules/rxjs/_esm2015/internal/scheduler/async.js","webpack:///node_modules/rxjs/_esm2015/internal/operators/debounceTime.js","webpack:///src/app/core/services/category.service.ts"],"names":["distinctUntilChanged","compare","keySelector","source","lift","DistinctUntilChangedOperator","this","subscriber","subscribe","DistinctUntilChangedSubscriber","destination","super","hasKey","x","y","value","key","err","error","result","next","TabId","Icons","Avatars","Test","IconManagement","CategoryManagement","BackgroundManagement","IconsBulkUpload","BgBulkUpload","async","debounceTime","dueTime","scheduler","a","DebounceTimeOperator","DebounceTimeSubscriber","debouncedSubscription","lastValue","hasValue","clearDebounce","add","schedule","dispatchNext","debouncedNext","complete","remove","unsubscribe","CategoryService","httpClient","forceReload","getCategories$","get","apiUrl","pipe","refCount","category","patch","post","categoryId","delete"],"mappings":"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","file":"x","sourcesContent":["import { Subscriber } from '../Subscriber';\nexport function distinctUntilChanged(compare, keySelector) {\n    return (source) => source.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nclass DistinctUntilChangedOperator {\n    constructor(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    }\n}\nclass DistinctUntilChangedSubscriber extends Subscriber {\n    constructor(destination, compare, keySelector) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    compare(x, y) {\n        return x === y;\n    }\n    _next(value) {\n        let key;\n        try {\n            const { keySelector } = this;\n            key = keySelector ? keySelector(value) : value;\n        }\n        catch (err) {\n            return this.destination.error(err);\n        }\n        let result = false;\n        if (this.hasKey) {\n            try {\n                const { compare } = this;\n                result = compare(this.key, key);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (!result) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    }\n}\n//# sourceMappingURL=distinctUntilChanged.js.map","export enum TabId {\n  Icons,\n  Avatars,\n  Test,\n  IconManagement,\n  CategoryManagement,\n  BackgroundManagement,\n  IconsBulkUpload,\n  BgBulkUpload,\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\nexport const async = asyncScheduler;\n//# sourceMappingURL=async.js.map","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function debounceTime(dueTime, scheduler = async) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass DebounceTimeSubscriber extends Subscriber {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map","import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { shareReplay } from 'rxjs/operators';\n\nimport { environment } from '../../../environments/environment';\nimport { CategoryDto } from '../../models/dto/category-dto';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CategoryService {\n  private getCategories$: Observable<CategoryDto[]>;\n\n  constructor(private readonly httpClient: HttpClient) {}\n\n  public getCategories(forceReload = false) {\n    if (this.getCategories$ && !forceReload) {\n      return this.getCategories$;\n    }\n\n    this.getCategories$ = this.httpClient\n      .get<CategoryDto[]>(`${environment.apiUrl}/categories`)\n      .pipe(shareReplay(1), shareReplay({ refCount: true }));\n    return this.getCategories$;\n  }\n\n  public patchCategory(category: Partial<CategoryDto>) {\n    return this.httpClient.patch<void>(`${environment.apiUrl}/categories`, { category });\n  }\n\n  public addCategory(category: CategoryDto) {\n    return this.httpClient.post<CategoryDto>(`${environment.apiUrl}/categories`, { category });\n  }\n\n  public deleteCategory(categoryId: string) {\n    return this.httpClient.delete<void>(`${environment.apiUrl}/categories/${categoryId}`);\n  }\n}\n"]}