{"version":3,"sources":["webpack:///node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js","webpack:///src/app/models/enums/tab-id.ts","webpack:///node_modules/rxjs/_esm2015/internal/scheduler/async.js","webpack:///node_modules/rxjs/_esm2015/internal/operators/debounceTime.js","webpack:///src/app/core/services/category.service.ts"],"names":["distinctUntilChanged","compare","keySelector","source","lift","DistinctUntilChangedOperator","this","subscriber","subscribe","DistinctUntilChangedSubscriber","destination","super","hasKey","x","y","value","key","err","error","result","next","TabId","Icons","Avatars","Test","IconManagement","CategoryManagement","BackgroundManagement","IconsBulkUpload","BgBulkUpload","async","debounceTime","dueTime","scheduler","a","DebounceTimeOperator","DebounceTimeSubscriber","debouncedSubscription","lastValue","hasValue","clearDebounce","add","schedule","dispatchNext","debouncedNext","complete","remove","unsubscribe","CategoryService","httpClient","forceReload","getCategories$","get","apiUrl","pipe","refCount","category","patch","post","categoryId"],"mappings":"y8CAAA,gDACO,SAASA,EAAqBC,EAASC,GAC1C,OAAQC,YAAM,OAAKA,EAAOC,KAAK,IAAIC,EAA6BJ,EAASC,K,IAEvEG,E,WACF,WAAYJ,EAASC,GAAY,UAC7BI,KAAKL,QAAUA,EACfK,KAAKJ,YAAcA,E,uCAElBK,EAAYJ,GACb,OAAOA,EAAOK,UAAU,IAAIC,EAA+BF,EAAYD,KAAKL,QAASK,KAAKJ,kB,KAG5FO,E,8BACF,WAAYC,EAAaT,EAASC,GAAY,wBAC1CS,cAAMD,IACDR,YAAcA,EACnBI,EAAKM,UACkB,mBAAZX,IACPK,EAAKL,QAAUA,GALuB,E,0CAQtCY,EAAGC,GACP,OAAOD,IAAMC,I,4BAEXC,GACF,IAAIC,EACJ,IAAG,IACSd,EAAgBI,KAAlB,YACNU,EAAMd,EAAcA,EAAYa,GAASA,EAE7C,MAAOE,GACH,OAAOX,KAAKI,YAAYQ,MAAMD,GAElC,IAAIE,KACJ,GAAIb,KAAKM,OACL,IAEIO,GAASlB,EADWK,KAAd,SACWA,KAAKU,IAAKA,GAE/B,MAAOC,GACH,OAAOX,KAAKI,YAAYQ,MAAMD,QAIlCX,KAAKM,UAEJO,IACDb,KAAKU,IAAMA,EACXV,KAAKI,YAAYU,KAAKL,Q,GApCW,M,oCCb7C,oCAAYM,EAAZ,SAAYA,G,OACV,IAAAC,MAAA,WACA,IAAAC,QAAA,aACA,IAAAC,KAAA,UACA,IAAAC,eAAA,oBACA,IAAAC,mBAAA,wBACA,IAAAC,qBAAA,0BACA,IAAAC,gBAAA,qBACA,IAAAC,aAAA,kBARUR,EAAZ,CASC,K,kCCTD,gDAGaS,EADiB,IAF9B,UAE8B,GAAmB,M,kCCFjD,4DAEO,SAASC,EAAaC,GAAqB,IAAZC,EAAY,yDAAAC,EAC9C,OAAQ/B,YAAM,OAAKA,EAAOC,KAAK,IAAI+B,EAAqBH,EAASC,K,IAE/DE,E,WACF,WAAYH,EAASC,GAAU,UAC3B3B,KAAK0B,QAAUA,EACf1B,KAAK2B,UAAYA,E,uCAEhB1B,EAAYJ,GACb,OAAOA,EAAOK,UAAU,IAAI4B,EAAuB7B,EAAYD,KAAK0B,QAAS1B,KAAK2B,gB,KAGpFG,E,8BACF,WAAY1B,EAAasB,EAASC,GAAU,wBACxCtB,cAAMD,IACDsB,QAAUA,EACf1B,EAAK2B,UAAYA,EACjB3B,EAAK+B,sBAAwB,KAC7B/B,EAAKgC,UAAY,KACjBhC,EAAKiC,YANmC,E,wCAQtCxB,GACFT,KAAKkC,gBACLlC,KAAKgC,UAAYvB,EACjBT,KAAKiC,YACLjC,KAAKmC,IAAInC,KAAK+B,sBAAwB/B,KAAK2B,UAAUS,SAASC,EAAcrC,KAAK0B,QAAS1B,S,kCAG1FA,KAAKsC,gBACLtC,KAAKI,YAAYmC,a,sCAIjB,GADAvC,KAAKkC,gBACDlC,KAAKiC,SAAU,CAAC,IACRD,EAAchC,KAAhB,UACNA,KAAKgC,UAAY,KACjBhC,KAAKiC,YACLjC,KAAKI,YAAYU,KAAKkB,M,sCAI1B,IAAMD,EAAwB/B,KAAK+B,sBACL,OAA1BA,IACA/B,KAAKwC,OAAOT,GACZA,EAAsBU,cACtBzC,KAAK+B,sBAAwB,U,GAjCJ,KAqCrC,SAASM,EAAapC,GAClBA,EAAWqC,kB,oCCjDf,oFAQO,iBAAMI,EAAN,WAGL,WAA6BC,aAAA,KAAAA,aAHxB,kDAK8B,IAAdC,EAAc,wDACjC,OAAI5C,KAAK6C,iBAAmBD,IAI5B5C,KAAK6C,eAAiB7C,KAAK2C,WACxBG,IAAsB,IAAYC,OAAf,eACnBC,KAAK,YAAY,GAAI,YAAY,CAAEC,UAAS,MALtCjD,KAAK6C,iBAPX,oCAgBgBK,GACnB,OAAOlD,KAAK2C,WAAWQ,MAAe,IAAYJ,OAAf,cAAoC,CAAEG,eAjBtE,kCAoBcA,GACjB,OAAOlD,KAAK2C,WAAWS,KAAqB,IAAYL,OAAf,cAAoC,CAAEG,eArB5E,qCAwBiBG,GACpB,OAAOrD,KAAK2C,WAAL3C,iBAAgC,IAAY+C,OAA5C/C,uBAAiEqD,QAzBrE,K,6CAAMX,GAAe,Y,yBAAfA,EAAe,QAAfA,EAAe,qBAFd,S,EAEP,O","file":"x","sourcesContent":["import { Subscriber } from '../Subscriber';\nexport function distinctUntilChanged(compare, keySelector) {\n    return (source) => source.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nclass DistinctUntilChangedOperator {\n    constructor(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    }\n}\nclass DistinctUntilChangedSubscriber extends Subscriber {\n    constructor(destination, compare, keySelector) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    compare(x, y) {\n        return x === y;\n    }\n    _next(value) {\n        let key;\n        try {\n            const { keySelector } = this;\n            key = keySelector ? keySelector(value) : value;\n        }\n        catch (err) {\n            return this.destination.error(err);\n        }\n        let result = false;\n        if (this.hasKey) {\n            try {\n                const { compare } = this;\n                result = compare(this.key, key);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (!result) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    }\n}\n//# sourceMappingURL=distinctUntilChanged.js.map","export enum TabId {\n  Icons,\n  Avatars,\n  Test,\n  IconManagement,\n  CategoryManagement,\n  BackgroundManagement,\n  IconsBulkUpload,\n  BgBulkUpload,\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\nexport const async = asyncScheduler;\n//# sourceMappingURL=async.js.map","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function debounceTime(dueTime, scheduler = async) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass DebounceTimeSubscriber extends Subscriber {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map","import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { shareReplay } from 'rxjs/operators';\n\nimport { environment } from '../../../environments/environment';\nimport { CategoryDto } from '../../models/dto/category-dto';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CategoryService {\n  private getCategories$: Observable<CategoryDto[]>;\n\n  constructor(private readonly httpClient: HttpClient) {}\n\n  public getCategories(forceReload = false) {\n    if (this.getCategories$ && !forceReload) {\n      return this.getCategories$;\n    }\n\n    this.getCategories$ = this.httpClient\n      .get<CategoryDto[]>(`${environment.apiUrl}/categories`)\n      .pipe(shareReplay(1), shareReplay({ refCount: true }));\n    return this.getCategories$;\n  }\n\n  public patchCategory(category: Partial<CategoryDto>) {\n    return this.httpClient.patch<void>(`${environment.apiUrl}/categories`, { category });\n  }\n\n  public addCategory(category: CategoryDto) {\n    return this.httpClient.post<CategoryDto>(`${environment.apiUrl}/categories`, { category });\n  }\n\n  public deleteCategory(categoryId: string) {\n    return this.httpClient.delete<void>(`${environment.apiUrl}/categories/${categoryId}`);\n  }\n}\n"]}